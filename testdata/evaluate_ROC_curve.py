#!/usr/bin/python3

"""
  This script loads a weights file together with a validation data directory and
  generates data for a ROC curve given different "minimum distances".

  Precision and Recall are calculated using their information-retrieval versions:

  Precision = # of retrieved relevant / # of total retrieved
  Recall = # of retrieved relevant / # of total relevant
"""
from collections import defaultdict
import random, sys
import functionsimsearchutil
import functionsimsearch
import numpy as np
from absl import app
from absl import flags

flags.DEFINE_string('symbols', 'symbols.txt', 'Symbols file in the same ' +\
  'format as generated by the ./generate_training_data.py. Needs to contain ' +\
  'symbols for all the functions.')

flags.DEFINE_string('dbdump', 'dbdump.txt', 'Database dump in the same ' +\
  'format as generated by dumpfunctionindex -- a 5-column text file with the ' +\
  'first column zero, the 2nd and 3rd the SimHash, then file-id and address')

flags.DEFINE_string('index', 'db.index', 'The search index that the previous ' +\
  'two arguments depend on / are generated from.')

FLAGS = flags.FLAGS

class SearchResult:
  def __init__(self, distance, function_info):
    self.distance = distance
    self.simhash = function_info[0]
    self.function_name = function_info[1]
    self.file_name = function_info[2]
    self.file_id = function_info[3]
    self.address = function_info[4]

class LabeledDataManager:
  def __init__(self, symbols, dbdump, index):
    self.total_number_of_functions = 0
    # A dictionary that maps a tuple (file_id, address) to the full description
    # of that function (e.g. a tuple consisting of (hash, function, file_name,
    # file_id, address).
    self.function_lookup = {}
    # Populate this dictionary. Retrieve functions and file ids and addresses.
    functions = functionsimsearchutil.read_inputs(symbols, dbdump, True)
    self.function_lookup = {}
    for function in functions:
      self.function_lookup[int(function[3], 16), int(function[4], 16)] = function

    # A dictionary that maps a function name to a list of it's implementations.
    self.functions_to_implementations = defaultdict(list)
    for function in functions:
      self.functions_to_implementations[function[1]].append(function)
      self.total_number_of_functions = self.total_number_of_functions + 1

    # The actual search index.
    self.index = functionsimsearch.SimHashSearchIndex(index, False, 50)

  def search_exact(self, simhash):
    """
      Use precise search and return a sorted list of all the functions and the
      respective distances.
    """
    hash_A, hash_B = self.split_uint128(simhash)
    resultlist = []
    for function_list in self.functions_to_implementations.values():
      for function in function_list:
        other_hash_A, other_hash_B = self.split_uint128(function[0])
        distance = 128.0-functionsimsearch.distance(hash_A, hash_B, other_hash_A,
          other_hash_B)
        resultlist.append(SearchResult(distance, function))
    resultlist.sort(key = lambda x : (x.distance, x.simhash), reverse = True)
    return resultlist

  def search_approximate(self, simhash):
    """
      Use the approximate search to return a list of functions and their
      distances.
    """
    hash_A, hash_B = self.split_uint128(simhash)
    resultlist = []
    results = self.index.query_top_N(hash_A, hash_B, 200000)
    total_results = len(results)
    missing_info = 0
    for element in results:
      result2 = self.function_lookup.get((element[1], element[2]))
      distance = element[0]
      if result2:
        resultlist.append(SearchResult(distance, result2))
      else:
        missing_info = missing_info + 1
    resultlist.sort(key = lambda x : (x.distance, x.simhash), reverse = True)
    return resultlist

  def split_uint128(self, simhash):
    result = (
      (simhash >> 64) & 0xFFFFFFFFFFFFFFFF,
      simhash & 0xFFFFFFFFFFFFFFFF)
    return result

  def function_info_to_file_id_address(self, function_info):
    """
      Convert a tuple with information about a function to a file_id, address
      tuple.
    """
    return (int(function_info[3], 16), int(function_info[4], 16))

  def count_relevant_results(self, function_name, result_list):
    implementations = self.functions_to_implementations[function_name]
    temporary_dict = {}
    relevant_count = 0
    for implementation in implementations:
      temporary_dict[self.function_info_to_file_id_address(implementation)] = \
        implementation
    for result in result_list:
      if temporary_dict.get((int(result.file_id, 16), int(result.address, 16))):
        relevant_count = relevant_count + 1
    return relevant_count

  def get_function_subset(self, number, get_all = False):
    if get_all or number > len(self.functions_to_implementations.keys()):
      return [x for x in self.functions_to_implementations.keys()]
    function_subset = np.random.choice( [ x for x in function_map.keys() ],
      number, replace=False)
    return function_subset

  def random_implementation(self, function_name):
    return random.choice(self.functions_to_implementations[function_name])

  def get_implementations(self, function_name):
    return self.functions_to_implementations[function_name]

  def how_many_relevant_and_irrelevant(self, function_name):
    relevant = len(self.functions_to_implementations[function_name])
    return (relevant, self.total_number_of_functions - relevant)

def main(argv):
  del argv # unused.

  # Refuse to run on Python less than 3.5 (unpredictable!).
  if sys.version_info[0] < 3 or sys.version_info[1] < 5:
    print("This script requires Python version 3.5 or higher.")
    sys.exit(1)

  data = LabeledDataManager(FLAGS.symbols, FLAGS.dbdump, FLAGS.index)

  function_subset = data.get_function_subset(300, get_all=True)

  exact_results = {}
  approximate_results = {}

  for distance in range(128, 0, -1):
    true_positive_rates_exact = []
    true_positive_rates_approx = []
    false_positive_rates_exact = []
    false_positive_rates_approx = []
    irrelevant_in_exact = []
    irrelevant_in_approx = []

    for function in function_subset:
      implementation = data.random_implementation(function)
      simhash = implementation[0]
      if not exact_results.get(function):
        exact_results[function] = data.search_exact(simhash)
      if not approximate_results.get(function):
        approximate_results[function] = data.search_approximate(simhash)

      exact = [result for result in exact_results[function] if result.distance >=
        (128.0 - distance)]
      approximate = [result for result in approximate_results[function] if
        result.distance >= (128.0 - distance)]

      relevant_exact = data.count_relevant_results(function, exact)
      relevant_approximate = data.count_relevant_results(function, approximate)
      total_relevant, total_irrelevant = \
        data.how_many_relevant_and_irrelevant(function)

      true_positive_rate_exact = relevant_exact / total_relevant
      count_of_irrelevant_exact_results = len(exact) - relevant_exact
      false_positive_rate_exact = count_of_irrelevant_exact_results / \
        total_irrelevant

      true_positive_rate_approx = relevant_approximate / total_relevant
      count_of_irrelevant_approx_results = len(approximate) - relevant_approximate
      false_positive_rate_approx = count_of_irrelevant_approx_results / \
        total_irrelevant

      percentage_of_irrelevant_exact = count_of_irrelevant_exact_results / len(exact)
      percentage_of_irrelevant_approx = count_of_irrelevant_approx_results / len(approximate)

      true_positive_rates_exact.append(true_positive_rate_exact)
      true_positive_rates_approx.append(true_positive_rate_approx)
      false_positive_rates_exact.append(false_positive_rate_exact)
      false_positive_rates_approx.append(false_positive_rate_approx)
      irrelevant_in_exact.append(percentage_of_irrelevant_exact)
      irrelevant_in_approx.append(percentage_of_irrelevant_approx)

    tpr_exact = np.mean(true_positive_rates_exact)
    fpr_exact = np.mean(false_positive_rates_exact)
    tpr_approx = np.mean(true_positive_rates_approx)
    fpr_approx = np.mean(false_positive_rates_approx)
    irrelevant_exact = np.mean(irrelevant_in_exact)
    irrelevant_approx = np.mean(irrelevant_in_approx)
    print("%d %f %f %f %f %f %f" % (distance, tpr_exact, fpr_exact, tpr_approx,
      fpr_approx, irrelevant_exact, irrelevant_approx))

if __name__ == '__main__':
  app.run(main)

